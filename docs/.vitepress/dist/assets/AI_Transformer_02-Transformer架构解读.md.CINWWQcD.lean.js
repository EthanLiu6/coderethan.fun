import{_ as a,c as o,o as t,a2 as r}from"./chunks/framework.DA-Pb-tg.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"AI/Transformer/02-Transformer架构解读.md","filePath":"AI/Transformer/02-Transformer架构解读.md","lastUpdated":null}'),l={name:"AI/Transformer/02-Transformer架构解读.md"};function n(i,e,s,p,c,d){return t(),o("div",null,e[0]||(e[0]=[r('<h2 id="_02-transformer架构解读" tabindex="-1">02-Transformer架构解读 <a class="header-anchor" href="#_02-transformer架构解读" aria-label="Permalink to &quot;02-Transformer架构解读&quot;">​</a></h2><blockquote><p>整理来源于作者：<a href="https://www.cnblogs.com/rossiXYZ%EF%BC%8C%E5%B7%B2%E8%8E%B7%E5%BE%97%E8%AE%B8%E5%8F%AF" target="_blank" rel="noreferrer">https://www.cnblogs.com/rossiXYZ，已获得许可</a></p></blockquote><h3 id="_2-1-整体结构" tabindex="-1">2.1 整体结构 <a class="header-anchor" href="#_2-1-整体结构" aria-label="Permalink to &quot;2.1 整体结构&quot;">​</a></h3><p>从网络结构来分析，Transformer 包括了四个主体模块。</p><blockquote><ul><li>输入模块，对应下图的绿色圈。</li><li>编码器（Encoder），对应下图的蓝色圈。</li><li>解码器（Decoder），对应下图的红色圈。编码器和解码器都有自己的输入和输出，编码器的输出会作为解码器输入的一部分（位于解码器的中间的橙色圈）。</li><li>输出模块，对应下图的紫色圈。</li></ul></blockquote><p>确切的说，蓝色圈是编码器层（Encoder layer），红色圈是解码器层（Decoder layer）。图中的 N×代表把若干具有相同结构的层堆叠起来，这种将同一结构重复多次的分层机制就是栈。为了避免混淆，我们后续把单个层称为编码器层或解码器层，把堆叠的结果称为编码器或解码器。在Transformer论文中，Transformer使用了6层堆叠来进行学习。</p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/1850883-20250209144200970-309684502.jpg" alt="img"></p><h3 id="_2-2-attention结构" tabindex="-1">2.2 Attention结构 <a class="header-anchor" href="#_2-2-attention结构" aria-label="Permalink to &quot;2.2 Attention结构&quot;">​</a></h3><p>在Transformer中有三种注意力结构：全局自注意力，掩码自注意力和交叉注意力，具体如下图所示。</p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/1850883-20250209144227590-945674250.jpg" alt="img"></p><p><img src="https://img2024.cnblogs.com/blog/1850883/202502/1850883-20250209144236400-880372719.jpg" alt="img"></p><p>论文解读三个Attention：</p><blockquote><p>Transformer 模型以三种不同的方式使用多头注意力机制：</p><ul><li>在“编码器 - 解码器注意力”层中，quary来自前一个解码器层，而记忆键和值来自编码器的输出。这使得解码器中的每个位置都能关注输入序列中的所有位置。这模仿了诸如[38, 2, 9]等序列到序列模型中典型的编码器 - 解码器注意力机制。</li><li>编码器包含自注意力层。在自注意力层中，所有的键、值和查询都来自同一个地方，在这种情况下，来自编码器前一层的输出。编码器中的每个位置都可以关注到编码器前一层中的所有位置。</li><li>同样，解码器中的自注意力层允许解码器中的每个位置关注到解码器中该位置之前的所有位置。我们需要防止解码器中的左向信息流以保持自回归属性。我们在缩放点积注意力内部通过掩码（设置为 -inf）来实现这一点，掩码掉 softmax 输入中对应于非法连接的所有值。</li></ul></blockquote><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/1850883-20250209144246216-890349384.jpg" alt="img"></p><h5 id="_1-全局自注意力层" tabindex="-1">1. 全局自注意力层 <a class="header-anchor" href="#_1-全局自注意力层" aria-label="Permalink to &quot;1. 全局自注意力层&quot;">​</a></h5><p>全局自注意力层（Global self attention layer）位于编码器中，它负责处理整个输入序列。在全局自注意力机制中，序列中的每个元素都可以直接访问序列中的其它元素，从而与序列中的其他元素建立动态的关联，这样可以使模型更好地捕捉序列中的重要信息。自注意力的意思就是关注于序列内部关系的注意力机制，那么是如何实现让模型关注序列内部之间的关系呢？自注意力将query、key、value设置成相同的东西，都是输入的序列，就是让注意力机制在序列的本身中寻找关系，注意到不同部分之间的相关性。</p><p>对于全局自注意力来说，Q、K、V有如下可能：</p><ul><li>Q、K、V都是输入序列。</li><li>Q、K、V都来自编码器中前一层的输出。编码器中的每个位置都可以关注编码器前一层输出的所有位置。</li></ul><p>再细化来说，Q是序列中当前位置的词向量，K和V是序列中的所有位置的词向量。</p><h5 id="_2-掩码自注意力" tabindex="-1">2. 掩码自注意力 <a class="header-anchor" href="#_2-掩码自注意力" aria-label="Permalink to &quot;2. 掩码自注意力&quot;">​</a></h5><p>掩码自注意力层或者说因果自注意力层（Causal attention layer）可以在解码阶段捕获当前词与已经解码的词之间的关联。它是对解码器的输入序列执行类似全局自注意力层的工作，但是又有不同之处。</p><p>Transformer是自回归模型，它逐个生成文本，然后将当前输出文本附加到之前输入上变成新的输入，后续的输出依赖于前面的输出词，具备因果关系。这种串行操作会极大影响训练模型的时间。<strong>为了并行提速，人们引入了掩码</strong>，这样在计算注意力时，通过掩码可以确保后面的词不会参与前面词的计算。</p><p>对于掩码自注意力来说，Q、K、V有如下可能：</p><ul><li>Q、K、V都是解码器的输入序列。</li><li>Q、K、V都来自解码器中前一层的输出。解码器中的每个位置都可以关注解码器前一层的所有位置。</li></ul><p>再细化来说，Q是序列中当前位置的词向量，K和V是序列中的所有位置的词向量。</p><h5 id="_3-交叉注意力层" tabindex="-1">3. 交叉注意力层 <a class="header-anchor" href="#_3-交叉注意力层" aria-label="Permalink to &quot;3. 交叉注意力层&quot;">​</a></h5><p>交叉注意力层（Cross attention layer）其实就是传统的注意力机制。交叉注意力层位于解码器中，但是其连接了编码器和解码器，这样可以刻画输入序列和输出序列之间的全局依赖关系，完成输入和输出序列之间的对齐。因此它需要将目标序列作为Q，将上下文序列作为K和V。</p><p>对于交叉注意力来说，Q、K、V来自如下：</p><ul><li>Q来自前一个解码器层，是因果注意力层的输出向量。</li><li>K和V来自编码器输出的注意力向量。</li></ul><p>这使得解码器中的每个位置都能关注输入序列中的所有位置。另外，编码器并非只传递最后一步的隐状态，而是把所有时刻（对应每个位置）产生的所有隐状态都传给解码器，这就解决了中间语义编码上下文的长度是固定的问题。</p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/1850883-20250218212308574-176454824-20250318112643142.jpg" alt="img"></p><h3 id="_2-3-执行流程" tabindex="-1">2.3 执行流程 <a class="header-anchor" href="#_2-3-执行流程" aria-label="Permalink to &quot;2.3 执行流程&quot;">​</a></h3><p>我们再来结合模型结构图来简述推理阶段的计算流程，具体如下图所示。</p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/1850883-20250209144319485-2071213191.jpg" alt="img"></p><p>假设我们进行机器翻译工作，把中文”我吃了一个苹果“翻译成英文”I ate an apple“，在假设模型只有一层，执行步骤如下：</p><ol><li>处理输入。用户输入自然语言句子”我吃了一个苹果“；tokenizer先把序列转换成token序列；然后Input Embedding层对每个token进行embedding编码，再加入Positional Encoding（位置编码），最终形成带有位置信息的embedding编码矩阵。编码矩阵用 Xn∗dXn∗d 表示， n 是句子中单词个数，d 是表示向量的维度（论文中 d=512）。注：原论文图上的输入是token，本篇为了更好的说明，把输入设置为自然语言句子。</li><li>编码器进行编码。编码矩阵首先进入MHA（Multi-Head Attention，多头注意力）模块，在这里每个token会依据一定权重把自己的信息和其它token的信息进行交换融合；融合结果会进入FFN（Feed Forward Network）模块做进一步处理，最终得到整个句子的数学表示，句子中每个字都会带上其它字的信息。整个句子的数学表示就是Encoder的输出。</li><li>通过输入翻译开始符来启动解码器。</li><li>解码器进行解码。解码器首先进入Masked Multi-Head Attention模块，在这里解码器的输入序列会进行内部信息交换；然后在Multi-Head Attention模块中，解码器把自己的输入序列和编码器的输出进行融合转换，最终输出一个概率分布，表示词表中每个单词作为下一个输出单词的概率；最终依据某种策略输出一个最可能的单词。这里会预测出第一个单词”I“。</li><li>把预测出的第一个单词”I“和一起作为解码器的输入，进行再次解码。</li><li>解码器预测出第二个单词”ate“。</li></ol><p>针对本例，解码器的每一步输入和输出具体如下表所示。</p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/1850883-20250209144327875-1762767210.jpg" alt="img"></p><h2 id="_3-补充" tabindex="-1">3. 补充 <a class="header-anchor" href="#_3-补充" aria-label="Permalink to &quot;3. 补充&quot;">​</a></h2><p><strong>论文&quot;Attention is not all you need&quot;指出如果没有skip connection（residual connection-残差链接）和MLP，自注意力网络的输出会朝着一个rank-1的矩阵收缩。即，skip connection和MLP可以很好地阻止自注意力网络的这种”秩坍塌（秩坍塌）退化“。这揭示了skip connection，MLP对self-attention的不可或缺的作用</strong></p>',40)]))}const u=a(l,[["render",n]]);export{h as __pageData,u as default};
