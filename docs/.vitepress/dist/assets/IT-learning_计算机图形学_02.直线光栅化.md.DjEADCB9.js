import{_ as e,c as t,a2 as l,o}from"./chunks/framework.C9NVOr0y.js";const g=JSON.parse('{"title":"直线光栅化","description":"","frontmatter":{},"headers":[],"relativePath":"IT-learning/计算机图形学/02.直线光栅化.md","filePath":"IT-learning/计算机图形学/02.直线光栅化.md","lastUpdated":null}'),i={name:"IT-learning/计算机图形学/02.直线光栅化.md"};function r(c,a,n,p,s,h){return o(),t("div",null,a[0]||(a[0]=[l('<h1 id="直线光栅化" tabindex="-1">直线光栅化 <a class="header-anchor" href="#直线光栅化" aria-label="Permalink to &quot;直线光栅化&quot;">​</a></h1><h2 id="_1-引入" tabindex="-1">1. 引入 <a class="header-anchor" href="#_1-引入" aria-label="Permalink to &quot;1. 引入&quot;">​</a></h2><p>直线是所有图形中的基础，使用最多且最简单。</p><h2 id="_2-实现" tabindex="-1">2. 实现 <a class="header-anchor" href="#_2-实现" aria-label="Permalink to &quot;2. 实现&quot;">​</a></h2><blockquote><p>所有算法主要以斜率为 0 &lt; k &lt; 1的直线进行讲解</p></blockquote><h3 id="_2-1-基本实现思路" tabindex="-1">2.1 基本实现思路 <a class="header-anchor" href="#_2-1-基本实现思路" aria-label="Permalink to &quot;2.1 基本实现思路&quot;">​</a></h3><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241111195022157.png" alt="image-20241111195022157"></p><h3 id="_2-2-数值微分法-dda算法" tabindex="-1">2.2 数值微分法（DDA算法） <a class="header-anchor" href="#_2-2-数值微分法-dda算法" aria-label="Permalink to &quot;2.2 数值微分法（DDA算法）&quot;">​</a></h3><blockquote><p>直接法这里不再赘述，就是一个点一个点把坐标绘制出来（斜截式）</p></blockquote><p>该算法主要亮点就是引入了<strong>增量</strong>思想，对于<strong>最大位移方向</strong>（x和y增长哪个更快）上每次增加一个单位，对应的另一个方向（横纵坐标定位一个点）使用增量。</p><h4 id="_2-2-1-dda-算法概述" tabindex="-1">2.2.1 DDA 算法概述 <a class="header-anchor" href="#_2-2-1-dda-算法概述" aria-label="Permalink to &quot;2.2.1 DDA 算法概述&quot;">​</a></h4><p>DDA（Digital Differential Analyzer）算法是计算机图形学中最简单的直线绘制算法之一，其核心思想是基于直线公式 ($ y = kx + b $) 推导而来。DDA 算法的基本步骤是通过增量迭代，根据已知的起点坐标，逐步计算出直线上其他点的坐标，并将每个计算得到的坐标点向下取整后绘制出来。</p><h4 id="_2-2-2-算法步骤" tabindex="-1">2.2.2 算法步骤 <a class="header-anchor" href="#_2-2-2-算法步骤" aria-label="Permalink to &quot;2.2.2 算法步骤&quot;">​</a></h4><ol><li><p><strong>已知条件</strong>：给定直线的两个端点 $P_0(x_0, y_0)$和 $P_1(x_1, y_1)$，可以求出直线的斜率 $k$ 和截距 $b$ ：</p><ul><li>斜率 = $k = \\frac{y_1 - y_0}{x_1 - x_0}$</li><li>截距 $b$ 可省略，令起点坐标为$ (0, 0)$，从而简化计算。</li></ul></li><li><p><strong>增量公式</strong>：设当前点为 $(x_i, y_i)$，下一点 $(x_{i+1}, y_{i+1})$ 的计算公式为： $$ x_{i+1} = x_i + xStep \\ y_{i+1} = y_i + yStep $$</p></li><li><p><strong>步进方向选择</strong>：</p><ul><li><p>通过计算端点之间的增量差值 ($ \\Delta x = x_1 - x_0$ ) 和 ( $\\Delta y = y_1 - y_0$ ) 来确定 $xStep$ 和 $yStep$ 的取值。</p></li><li><p>如果 ( $|\\Delta x| &gt; |\\Delta y|$ )，说明 x 方向的差值更大，步进主方向在 x 轴（也就是最大位移方向），此时取：</p><ul><li>( $xStep = 1$ )</li><li>( $yStep = k = \\frac{\\Delta y}{\\Delta x} $)</li></ul></li><li><p>如果 ( $|\\Delta y| &gt; |\\Delta x|$ )，说明 y 方向的差值更大，步进主方向在 y 轴，此时取：</p><ul><li>($ yStep = 1$ )</li><li>( $xStep = \\frac{1}{k} = \\frac{\\Delta x}{\\Delta y}$ )</li></ul></li></ul></li><li><p><strong>坐标点绘制</strong>：根据公式迭代得到的 ((x, y)) 值向下取整，得到实际绘制的像素点 ((x&#39;, y&#39;))，在坐标系上绘制点 ((x&#39;, y&#39;))。</p></li></ol><h4 id="_2-2-3-伪代码演示" tabindex="-1">2.2.3 伪代码演示 <a class="header-anchor" href="#_2-2-3-伪代码演示" aria-label="Permalink to &quot;2.2.3 伪代码演示&quot;">​</a></h4><blockquote><p>斜率：0&lt;k&lt;1</p></blockquote><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241111201612868.png" alt="image-20241111201612868"></p><p>tip:: 注意</p><p>为保证绘制逼真，所有算法通常进行“<strong>像素中心偏移</strong>”——<code>int(y + 0.5)</code>，即对y添加0.5再取整</p><p>:::</p><h4 id="_2-2-4-优化方向" tabindex="-1">2.2.4 优化方向 <a class="header-anchor" href="#_2-2-4-优化方向" aria-label="Permalink to &quot;2.2.4 优化方向&quot;">​</a></h4><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241111201917519.png" alt="image-20241111201917519"></p><h3 id="_2-3-中心点画线法" tabindex="-1">2.3 中心点画线法 <a class="header-anchor" href="#_2-3-中心点画线法" aria-label="Permalink to &quot;2.3 中心点画线法&quot;">​</a></h3><blockquote><p>优化DDA算法</p></blockquote><p>该算法引入了直线的<strong>一般式方程</strong>，即$F_{(x,y)} = A_x + B_y + C = 0$，由于</p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241111202319092.png" alt="image-20241111202319092"></p><h4 id="_2-3-1-算法思想" tabindex="-1">2.3.1 算法思想 <a class="header-anchor" href="#_2-3-1-算法思想" aria-label="Permalink to &quot;2.3.1 算法思想&quot;">​</a></h4><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241111202548618.png" alt="image-20241111202548618"></p><p>很直观明了，下一个点的更新只会在——右边或者右上，是固定的，大家可以自己推导出对应点的坐标（后一个点是前一个点的横坐标加一或者横纵坐标都加一）</p><p>重点：这里就引出了一个关键问题——**如何确定下一个点是在右边还是右上角？**不妨选择他们的中点，然后带入直线的一般式方程，判断与0的关系即可知道下一个点的位置具体怎么确定（<strong>大家再仔细想想，不同情况的位置确定是如何的呢？</strong>）。</p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241111203121805.png" alt="image-20241111203121805"></p><h4 id="_2-3-2-算法步骤" tabindex="-1">2.3.2 算法步骤 <a class="header-anchor" href="#_2-3-2-算法步骤" aria-label="Permalink to &quot;2.3.2 算法步骤&quot;">​</a></h4><ul><li>确定最大位移方向</li><li>判断中点与直线位置关系（<strong>下面进行优化</strong>）</li><li>更根据不同的情况更新$y_{i+1}$（要么等于$y_i$，要么等于$y_{i}+1$​​，x始终是加一）</li><li>记得还要起点（计算初值）</li></ul><p><strong>算法进行优化</strong>，将$d_i$和$d_{i+1}$的递推关系式求解出来即可</p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241112002846587.png" alt="image-20241112002846587"> <img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241112002846587.png" alt=""></p><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241112003255752.png" alt="image-20241112003255752"></p><h4 id="_2-3-3-举例" tabindex="-1">2.3.3 举例 <a class="header-anchor" href="#_2-3-3-举例" aria-label="Permalink to &quot;2.3.3 举例&quot;">​</a></h4><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241112003334477.png" alt="image-20241112003334477"></p><h4 id="_2-3-4-伪代码演示" tabindex="-1">2.3.4 伪代码演示 <a class="header-anchor" href="#_2-3-4-伪代码演示" aria-label="Permalink to &quot;2.3.4 伪代码演示&quot;">​</a></h4><p><img src="https://coderethan-1327000741.cos.ap-chengdu.myqcloud.com/blog-pics/image-20241112003427200.png" alt="image-20241112003427200"></p><h3 id="_2-3-bresenham算法" tabindex="-1">2.3 Bresenham算法 <a class="header-anchor" href="#_2-3-bresenham算法" aria-label="Permalink to &quot;2.3 Bresenham算法&quot;">​</a></h3>',41)]))}const m=e(i,[["render",r]]);export{g as __pageData,m as default};
