import{_ as i,c as a,a2 as n,o as l}from"./chunks/framework.C9NVOr0y.js";const c=JSON.parse('{"title":"分发饼干问题","description":"","frontmatter":{},"headers":[],"relativePath":"生活与算法/贪心算法/3. 分发饼干问题.md","filePath":"生活与算法/贪心算法/3. 分发饼干问题.md","lastUpdated":1729514131000}'),h={name:"生活与算法/贪心算法/3. 分发饼干问题.md"};function t(e,s,k,p,d,r){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="分发饼干问题" tabindex="-1">分发饼干问题 <a class="header-anchor" href="#分发饼干问题" aria-label="Permalink to &quot;分发饼干问题&quot;">​</a></h1><div class="warning custom-block"><p class="custom-block-title">我的建议</p><p>如果你看见代码部分比较头疼，而且不想了解编程，完全可以跳过代码部分（建议看代码里的注释），不影响你正常理解算法思维，依旧能够对你的生活有启发作用。如果是计科或者编程相关人士，建议根据自己的编程语言和变成习惯来实现。</p></div><h2 id="_1-问题描述" tabindex="-1">1. 问题描述 <a class="header-anchor" href="#_1-问题描述" aria-label="Permalink to &quot;1. 问题描述&quot;">​</a></h2><p>有一群小孩和若干块饼干。每个小孩都有一个对饼干大小的需求，表示他们至少需要多大的饼干才能满足。每块饼干也有一个大小。你要将饼干分给这些小孩，使得尽可能多的小孩能得到满足。每个小孩最多只能分到一块饼干，而每块饼干只能给一个小孩。</p><h2 id="_2-目标" tabindex="-1">2. 目标 <a class="header-anchor" href="#_2-目标" aria-label="Permalink to &quot;2. 目标&quot;">​</a></h2><p>分发饼干，使得<strong>尽可能多的小孩得到满足</strong>。</p><h2 id="_3-输入" tabindex="-1">3. 输入： <a class="header-anchor" href="#_3-输入" aria-label="Permalink to &quot;3. 输入：&quot;">​</a></h2><ul><li>一个整数数组 <code>g</code>，<code>g[i]</code>表示第<code>i</code>个小孩的需求（胃口）大小。</li><li>一个整数数组 <code>s</code>，<code>s[j]</code>表示第<code>j</code>个饼干的大小。</li></ul><h2 id="_4-输出" tabindex="-1">4. 输出： <a class="header-anchor" href="#_4-输出" aria-label="Permalink to &quot;4. 输出：&quot;">​</a></h2><ul><li>一个整数，表示可以满足的小孩的最大数量。</li></ul><h2 id="_5-贪心算法的解法思路" tabindex="-1">5. 贪心算法的解法思路 <a class="header-anchor" href="#_5-贪心算法的解法思路" aria-label="Permalink to &quot;5. 贪心算法的解法思路&quot;">​</a></h2><p>由于我们希望尽可能多的小孩得到满足，可以用以下的贪心策略：</p><ol><li><strong>优先考虑胃口最小的小孩</strong>，因为这些小孩容易被小饼干满足，能先满足他们可以为后面胃口更大的小孩留出更大的饼干。</li><li><strong>用最小的饼干满足最小胃口的小孩</strong>，这样可以确保大饼干用于更大胃口的小孩，从而能够满足更多小孩。</li></ol><h2 id="_6-解题步骤" tabindex="-1">6. 解题步骤 <a class="header-anchor" href="#_6-解题步骤" aria-label="Permalink to &quot;6. 解题步骤&quot;">​</a></h2><ol><li>首先，对孩子的胃口数组 <code>g</code> 和饼干数组 <code>s</code> 进行排序，分别从最小的开始处理。</li><li>使用两个指针，一个指向 <code>g</code>（小孩胃口数组），一个指向 <code>s</code>（饼干大小数组）。</li><li>遍历饼干数组，尝试用每块饼干去满足胃口最小的孩子。如果当前饼干可以满足孩子的胃口，则将指针都向后移动；如果不能满足，就只移动饼干的指针，继续用下一块大饼干尝试满足同一个小孩。</li></ol><h2 id="_7-代码实现-python" tabindex="-1">7. 代码实现（Python） <a class="header-anchor" href="#_7-代码实现-python" aria-label="Permalink to &quot;7. 代码实现（Python）&quot;">​</a></h2><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findContentChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, s):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 对孩子的胃口和饼干大小进行排序</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    g.sort()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    s.sort()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 为了见名知意，这里吧前面说的i和j换成了child和cookie</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 孩子指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cookie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 饼干指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 尝试用饼干去满足孩子</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cookie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s[cookie] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> g[child]:  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 如果当前饼干能满足当前孩子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 孩子得到满足，移动孩子指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cookie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 移动饼干指针，无论是否满足都要处理下一个饼干</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> child  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 返回得到满足的孩子数量</span></span></code></pre></div><h2 id="_8-示例" tabindex="-1">8. 示例 <a class="header-anchor" href="#_8-示例" aria-label="Permalink to &quot;8. 示例&quot;">​</a></h2><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 孩子的胃口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 饼干的大小</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> findContentChildren(g, s)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 输出 1，因为只有一个小孩能得到满足</span></span></code></pre></div><h2 id="_9-时间复杂度" tabindex="-1">9. 时间复杂度 <a class="header-anchor" href="#_9-时间复杂度" aria-label="Permalink to &quot;9. 时间复杂度&quot;">​</a></h2><blockquote><p>关于时间复杂度的详细计算，我这里不再详细赘述</p></blockquote><ul><li>排序的时间复杂度是 <code>O(n log n)</code>，其中 <code>n</code> 是孩子和饼干数量的较大值。</li><li>遍历两个数组的时间复杂度是 <code>O(n)</code>。</li></ul><p>因此，总的时间复杂度为 <code>O(n log n)</code>。</p><h2 id="_10-贪心策略的解释" tabindex="-1">10. 贪心策略的解释 <a class="header-anchor" href="#_10-贪心策略的解释" aria-label="Permalink to &quot;10. 贪心策略的解释&quot;">​</a></h2><p>这种贪心策略能够保证最多的小孩得到满足，因为它避免了将小饼干浪费在大胃口的小孩身上，而是优先满足容易被小饼干满足的小孩，从而为后面的大胃口小孩保留更大的饼干。</p><h2 id="_11-思考" tabindex="-1">11. 思考 <a class="header-anchor" href="#_11-思考" aria-label="Permalink to &quot;11. 思考&quot;">​</a></h2><ol><li>可否让胃口最大的孩子吃相应最大（不大于胃口）的饼干？</li><li>尝试把<code>while</code>循环改写成<code>for</code>循环。</li><li>遍历过程中，应该考虑拿孩子遍历还是饼干，可否互换？</li></ol>`,27)]))}const E=i(h,[["render",t]]);export{c as __pageData,E as default};
