# 分发饼干问题

::: warning 我的建议
如果你看见代码部分比较头疼，而且不想了解编程，完全可以跳过代码部分（建议看代码里的注释），不影响你正常理解算法思维，依旧能够对你的生活有启发作用。如果是计科或者编程相关人士，建议根据自己的编程语言和变成习惯来实现。
:::

## 1. 问题描述

有一群小孩和若干块饼干。每个小孩都有一个对饼干大小的需求，表示他们至少需要多大的饼干才能满足。每块饼干也有一个大小。你要将饼干分给这些小孩，使得尽可能多的小孩能得到满足。每个小孩最多只能分到一块饼干，而每块饼干只能给一个小孩。

## 2. 目标
分发饼干，使得**尽可能多的小孩得到满足**。

## 3. 输入：
- 一个整数数组 `g`，`g[i]`表示第`i`个小孩的需求（胃口）大小。
- 一个整数数组 `s`，`s[j]`表示第`j`个饼干的大小。

## 4. 输出：
- 一个整数，表示可以满足的小孩的最大数量。

## 5. 贪心算法的解法思路

由于我们希望尽可能多的小孩得到满足，可以用以下的贪心策略：
1. **优先考虑胃口最小的小孩**，因为这些小孩容易被小饼干满足，能先满足他们可以为后面胃口更大的小孩留出更大的饼干。
2. **用最小的饼干满足最小胃口的小孩**，这样可以确保大饼干用于更大胃口的小孩，从而能够满足更多小孩。

## 6. 解题步骤

1. 首先，对孩子的胃口数组 `g` 和饼干数组 `s` 进行排序，分别从最小的开始处理。
2. 使用两个指针，一个指向 `g`（小孩胃口数组），一个指向 `s`（饼干大小数组）。
3. 遍历饼干数组，尝试用每块饼干去满足胃口最小的孩子。如果当前饼干可以满足孩子的胃口，则将指针都向后移动；如果不能满足，就只移动饼干的指针，继续用下一块大饼干尝试满足同一个小孩。

## 7. 代码实现（Python）

```python
def findContentChildren(g, s):
    # 对孩子的胃口和饼干大小进行排序
    g.sort()
    s.sort()
    
    # 为了见名知意，这里吧前面说的i和j换成了child和cookie
    child = 0  # 孩子指针
    cookie = 0  # 饼干指针
    
    # 尝试用饼干去满足孩子
    while child < len(g) and cookie < len(s):
        if s[cookie] >= g[child]:  # 如果当前饼干能满足当前孩子
            child += 1  # 孩子得到满足，移动孩子指针
        cookie += 1  # 移动饼干指针，无论是否满足都要处理下一个饼干
    
    return child  # 返回得到满足的孩子数量
```

## 8. 示例

```python
g = [1, 2, 3]  # 孩子的胃口
s = [1, 1]     # 饼干的大小

result = findContentChildren(g, s)
print(result)  # 输出 1，因为只有一个小孩能得到满足
```

## 9. 时间复杂度
> 关于时间复杂度的详细计算，我这里不再详细赘述

- 排序的时间复杂度是 `O(n log n)`，其中 `n` 是孩子和饼干数量的较大值。
- 遍历两个数组的时间复杂度是 `O(n)`。
  
因此，总的时间复杂度为 `O(n log n)`。

## 10. 贪心策略的解释
这种贪心策略能够保证最多的小孩得到满足，因为它避免了将小饼干浪费在大胃口的小孩身上，而是优先满足容易被小饼干满足的小孩，从而为后面的大胃口小孩保留更大的饼干。

## 11. 思考
1. 可否让胃口最大的孩子吃相应最大（不大于胃口）的饼干？
2. 尝试把`while`循环改写成`for`循环。
3. 遍历过程中，应该考虑拿孩子遍历还是饼干，可否互换？